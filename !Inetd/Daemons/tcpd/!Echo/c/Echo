#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include "kernel.h"
#include "swis.h"
#include "sys/errno.h"
#include "sys/types.h"
#include "sys/socket.h"
#include "sys/ioctl.h"
#include "sys/syslog.h"
#include "socklib.h"
#include "netinet/in.h"
#include "netdb.h"
#include "unixlib.h"
#include "wimp.h"
#include "toolbox.h"
#include "event.h"
#include "syslog.h"
#include "asyncsock.h"
#include "pollword.h"

#define NOSOCK -1

#define WimpVersion    310

static char *copyright="Echo tcp version 0.01 ©Bill Antonia 2 July 1998";

static  WimpPollBlock  poll_block;
static  MessagesFD     messages;
static  IdBlock        id_block;

static int wimp_messages[]={
           Wimp_MQuit,
           Wimp_MPreQuit,
           0};

static int toolbox_events[]={
           0};

int sock=NOSOCK;
fd_set afds,rfds;
int nfds=FD_SETSIZE;
int task;
int *pollword;

/* The actual service routines and buffer space size */

#define BUFSIZE        4096
#define DAEMONDIR      "<Echo$Dir>"
#define SERVICE        "Echo"
#define DAEMON         "DaemonLog"

char return_buf[BUFSIZE];
char *buf_err="Buffer overrun";

/* This daemon doesn't actually do anything here.
   The contents of the buffer is not modified and
   is just sent back as is. */
void service(char *buf) {
}

/* End of service routines and data */

void report_error(int errnum, char* errmess, int line) {
  syslogf(DAEMON, LOG_ERR, "TCP Echo error: 0x%x %s at line: %d", errnum, errmess, line);
}

void quit(void) {
  syslogf(DAEMON,LOG_INFO,"tcp %s service ending on socket %d",SERVICE,(int)sock);
  if (socketclose(sock)==-1)
    report_error(errno, "socket close failure", __LINE__-1);
  async_deallocate((int)sock,AsyncSocket_TASK);
  pollword_deallocate(task);
  syslog_logcomplete(DAEMON);
}

int pollword_event(int event_code,WimpPollBlock *event,IdBlock *id_block,void *handle) {
  int nfound=0;
  struct timeval t;
  _kernel_oserror *err;
  pollword_reset(task);
  t.tv_sec=0;
  t.tv_usec=1;
  bcopy((char *)&afds,(char *)&rfds,sizeof(rfds));
  if ((nfound=select(nfds, &rfds, (fd_set *)0, (fd_set *)0, &t))==-1) {
    if (errno!=EWOULDBLOCK) {
      report_error(errno, "select failure", __LINE__-2);
      quit();
      exit(1);
    }
  }
  if (nfound>0) {
    if (FD_ISSET(((int)sock),&rfds)) {
      char buf[BUFSIZE];
      int cc=socketread(sock, buf, BUFSIZE);
      if (cc==0) {
        quit();
        exit(0);
      }
      buf[cc]=0;
      //service(buf);
      if (strlen(return_buf)+strlen(buf)>BUFSIZE-1) {
        syslogf(DAEMON,LOG_ERR,buf_err);
        socketwrite(sock, buf_err, strlen(buf_err));
        quit();
        exit(0);
      }
      strcat(return_buf,buf);
      if (strchr(buf,'\n')!=NULL||strchr(buf,'\a')!=NULL) {
        if ((cc=socketwrite(sock, return_buf, strlen(return_buf)))==-1) {
          syslogf(DAEMON,LOG_ERR,"%s tcp error: %x %s",SERVICE,err->errnum,err->errmess);
        } else {
          return_buf[0]=0;
        }
      }
    }
  }
  if ((event->poll_word_non_zero.poll_word_contents&0x0000ff00)==0x00000300) {
    quit();
    exit(0);
  }
  return 1;
}

int null_event(int event_code,WimpPollBlock *event,IdBlock *id_block,void *handle) {
  quit();
  exit(0);
  return 1;
}

int quit_message(WimpMessage *message,void *handle) {
  message=message;
  handle=handle;
  quit();
  exit(0);
  return(1);
}

int main(int argc,char *argv[]) {
  int event_code,interval=0;
  _kernel_oserror *err;
  _kernel_swi_regs r;
  int on=1;
  int timeout=0;
  int i=2;
  sock=atoi(argv[1]);
  if (argc>2) {
    while (i<argc) {
      if (strcmp(argv[i],"-t")==0) {
        timeout=atoi(argv[i+1]);
        i+=2;
      }
    }
  }
  syslogf(DAEMON,LOG_INFO,"tcp %s service starting on socket %d",SERVICE,(int)sock);
  if (socketioctl(sock, FIOASYNC, &on)==-1) {
    report_error(errno, "socketioctl error", __LINE__-1);
    quit();
    exit(1);
  }
  if ((err=toolbox_initialise(0,WimpVersion,wimp_messages,toolbox_events,DAEMONDIR,&messages,&id_block,0,&task,0))!=NULL) {
    report_error(err->errnum, err->errmess, __LINE__-1);
    quit();
    exit(1);
  }
  if ((err=pollword_allocate(task,&pollword))!=NULL) {
    report_error(err->errnum, err->errmess, __LINE__-1);
    quit();
    exit(1);
  }
  if ((err=async_allocate(pollword,(int)sock,AsyncSocket_TASK))!=NULL) {
    report_error(err->errnum, err->errmess, __LINE__-1);
    quit();
    exit(1);
  }
  event_initialise(&id_block);
  if (timeout!=0) {
    event_set_mask(0xc01900);
    event_register_wimp_handler(-1,Wimp_ENull,null_event,0);
  }
  else
    event_set_mask(0xc01901);
  return_buf[0]=0;
  event_register_wimp_handler(-1,Wimp_EPollWordNonZero,pollword_event,0);
  event_register_message_handler(Wimp_MQuit,quit_message,0);
  event_register_message_handler(Wimp_MPreQuit,quit_message,0);
  FD_ZERO(&afds);
  FD_SET((int)sock,&afds);
  while (TRUE) {
    if (timeout!=0) {
      _kernel_swi(OS_ReadMonotonicTime,&r,&r);
      interval=r.r[0]+timeout*100;
    }
    event_poll_idle(&event_code,&poll_block,interval,(void *)pollword);
  }
  return 0;
}

